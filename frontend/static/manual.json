{"06. Code Management": {"What is Git?.md": "Directly from [Git's website](https://git-scm.com/)\n> Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows.\n\nHonestly, I don't plan on adding much to this subfolder. I use Git 99.9% of the time at work and most of the commands are muscle memory at this point; however, there are still some commands I simply don't use b/c I never found them to be useful (i.e.: `git rebase`)\n\n[Cheat sheet](https://education.github.com/git-cheat-sheet-education.pdf)"}, "03. Networking": {"01. Protocols.md": "# IP (Interent Protocol)\n\nMethod for sending data from one device to another across the internet. Every device has an IP address that uniquely identifies it and enables it to communicate with and exchange data with other devices connected to the internet.  Today, it\u2019s considered the standard for fast and secure communication directly between mobile devices.\n\n## IPv4\nIPv4 stands for Internet Protocol version 4. It is the underlying technology that makes it possible for us to connect our devices to the web. Whenever a device accesses the Internet, it is assigned a unique, numerical IP address such as 99.48.227.227. To send data from one computer to another through the web, a data packet must be transferred across the network containing the IP addresses of both devices.\n\n## IPv6\nIPv6 is the next generation Internet Protocol (IP) address standard intended to supplement and eventually replace IPv4, the protocol many Internet services still use today. Every computer, mobile phone, home automation component, IoT sensor and any other device connected to the Internet needs a numerical IP address to communicate between other devices. The original IP address scheme, called IPv4, is running out of addresses due to its widespread usage from the proliferation of so many connected devices.\n\nFor those interested, an IPv6 address is made up of eight groups of four hexadecimal digits. These are separated by colons rather than full stops.\n\n[credit1](https://www.fortinet.com/resources/cyberglossary/tcp-ip) [credit2](https://www.thousandeyes.com/learning/techtorials/ipv4-vs-ipv6) [credit3](https://cybernews.com/what-is-vpn/ipv4-vs-ipv6/)\n\n# TCP (Transmission Control Protocol)\nCommunication standard that enables application programs and computing devices to exchange messages over a network. Designed to send packets across the internet and ensure the successful delivery of data & messages over networks\n\nTCP guarantees the integrity of the data being communicated over the network. \n\nTCP establishes a connection between a source and its destination, which it ensures remains live until communication begins. It then breaks large amounts of data into smaller packets, while ensuring data integrity is in place throughout the process.\n\nAs a result, high-level protocols that need to transmit data all use TCP Protocol.  Examples include peer-to-peer sharing methods like File Transfer Protocol (FTP), Secure Shell (SSH), and Telnet. It is also used to send and receive email through Internet Message Access Protocol (IMAP), Post Office Protocol (POP), and Simple Mail Transfer Protocol (SMTP), and for web access through the Hypertext Transfer Protocol (HTTP).\n\nTCP can be an expensive network tool as it includes absent or corrupted packets and protects data delivery with controls like acknowledgments, connection startup, and flow control.\n\n## TCP/IP\nTCP/IP divides communication tasks into layers that keep the process standardized, without hardware and software providers doing the management themselves. The data packets must pass through four layers before they are received by the destination device, then TCP/IP goes through the layers in reverse order to put the message back into its original format.\n\nAs a connection based protocol, the TCP establishes and maintains a connection between applications or devices until they finish exchanging data. It determines how the original message should be broken into packets, numbers and reassembles the packets, and sends them on to other devices on the network, such as routers, security gateways, and switches, then on to their destination. TCP also sends and receives packets from the network layer, handles the transmission of any dropped packets, manages flow control, and ensures all packets reach their destination.\n\nA good example of how this works in practice is when an email is sent using SMTP from an email server. To start the process, the TCP layer in the server divides the message into packets, numbers them, and forwards them to the IP layer, which then transports each packet to the destination email server. When packets arrive, they are handed back to the TCP layer to be reassembled into the original message format and handed back to the email server, which delivers the message to a user\u2019s email inbox.\n\nTCP/IP uses a three-way handshake to establish a connection between a device and a server, which ensures multiple TCP socket connections can be transferred in both directions concurrently. Both the device and server must synchronize and acknowledge packets before communication begins, then they can negotiate, separate, and transfer TCP socket connections.\n\nThe four layers of the TCP/IP model are as follows:\n1. Datalink layer: The datalink layer defines how data should be sent, handles the physical act of sending and receiving data, and is responsible for transmitting data between applications or devices on a network. This includes defining how data should be signaled by hardware and other transmission devices on a network, such as a computer\u2019s device driver, an Ethernet cable, a network interface card (NIC), or a wireless network. It is also referred to as the link layer, network access layer, network interface layer, or physical layer and is the combination of the physical and data link layers of the Open Systems Interconnection (OSI) model, which standardizes communications functions on computing and telecommunications systems.\n2. Internet layer: The internet layer is responsible for sending packets from a network and controlling their movement across a network to ensure they reach their destination. It provides the functions and procedures for transferring data sequences between applications and devices across networks.\n3. Transport layer: The transport layer is responsible for providing a solid and reliable data connection between the original application or device and its intended destination. This is the level where data is divided into packets and numbered to create a sequence. The transport layer then determines how much data must be sent, where it should be sent to, and at what rate. It ensures that data packets are sent without errors and in sequence and obtains the acknowledgment that the destination device has received the data packets. Some of the responsibilites of the transport layer are as follows:\n    1. End to end delivery\n    2. Reliability\n    3. Error control\n    4. Flow control\n    5. Multiplexing & demultiplexing\n4. Application layer: The application layer refers to programs that need TCP/IP to help them communicate with each other. This is the level that users typically interact with, such as email systems and messaging platforms. It combines the session, presentation, and application layers of the OSI model.\n\nReal-life examples:\n\n- Text communication\n    - We all are aware of the importance of Text Communication in the present times. Any discrepancy in texting between sender and receiver cannot be tolerated. Hence TCP is used in Text Communication due to its reliable transmission, error control, and in order receiving of the data. \n    Example: Whatsapp, Instagram, Google Chat,iMessage.\n\n- FTP (File Transport Protocol)\n    - TCP is used in File transfer when we cannot tolerate the loss of data and receiving the data incorrect order is of utmost importance. FTP uses two TCP connections i.e control connection and data connection\n        - Control Connection : FTP sends information like user identification and passwords\n        - Data Connection: In this connection, files are sent over the network.\n    \n        Example: FileZilla\n\n- HTTP (HyperText Transfer Protocol)\n    - It is used to access the data present on the World Wide Web. It uses TCP protocol for accessing the web pages present on the internet due to the fact that TCP provides inorder data, error control and flow control, and retransmission of data segments.\n\n- SMTP (Simple Mail Transfer Protocol)\n    - It is an application layer protocol that is used to send Emails from one system to another. SMTP uses the services of TCP to start a connection with the SMTP server. Once the SMTP server accepts the connection request, it allows the sender to send the mails. Example: Yahoo, Gmail, Outlook, etc\n\n[credit1](https://www.fortinet.com/resources/cyberglossary/tcp-ip) [credit2](https://www.geeksforgeeks.org/examples-of-tcp-and-udp-in-real-life/)\n\n# UDP (User Datagram Protocol)\n\nUsed to establish low-latency connections between applications and decrease transmissions time\n\nUDP does not provide error connection or packet sequencing nor does it signal a destination before it delivers data, which makes it less reliable but less expensive. As such, it is a good option for time-sensitive situations, such as Domain Name System (DNS) lookup, Voice over Internet Protocol (VoIP), and streaming media.\n\nReal-life examples:\n\n- Online games\n    - Most of the online games we play use the services of User Datagram Protocol. Since any amount of delay cannot be tolerated in online games UDP is widely used over TCP which is quite slower. UDP doesn\u2019t retransmit the lost data and is a connectionless protocol due to which it is much faster.\n\n- Video conferencing\n    - Video Conferencing apps like Skype, Gmeet, Zoom, all use the services of UDP due to the fact that they are real-time applications and any delay in receiving the data cannot be tolerated. Examples: Skype, Google, Zoom, FaceTime\n\n- VOIP (Voice over IP)\n    - It is similar to Video Conferencing, where apps like Viber, Whatsapp, Google Hangouts use UDP for converting our voice to digital data and transmit it over the network, hence the name VoIP. Examples: WhatsApp Voice, Google Voice\n\n- DNS (Domain Name Systems)\n    - It is a service used for mapping domain names to their corresponding IP address. It is used by the application layer. It can also be looked at as a distributed DataBase that has a hierarchical name Server. DNS uses UDP for fetching the corresponding IP address. The DNS is like the yellowpage of website domain names and their respected server IP addresses\n\n[credit1](https://www.fortinet.com/resources/cyberglossary/tcp-ip) [credit2](https://www.geeksforgeeks.org/examples-of-tcp-and-udp-in-real-life/)\n\n# HTTP (Hypertext Transfer Protocol) & HTTPS (Hypertext Transfer Protocol Secure)\n## HTTP (Hypertext Transfer Protocol)\nThe Hypertext Transfer Protocol (HTTP) is the foundation of the World Wide Web, and is used to load webpages using hypertext links. HTTP is an application layer protocol designed to transfer information between networked devices and runs on top of other layers of the network protocol stack. A typical flow over HTTP involves a client machine making a request to a server, which then sends a response message.\n\nA typical HTTP request contains:\n- HTTP version type\n    - HTTP/0.9, HTTP/1.0, HTTP/1.1, and HTTP/2.0\n- URL\n    - http://google.com\n- HTTP method\n    - The primary or most commonly-used HTTP methods are POST, GET, PUT, PATCH, and DELETE. These methods correspond to create, read, update, and delete (or CRUD) operations, respectively.\n- Request headers\n    - ![img](https://www.cloudflare.com/img/learning/ddos/glossary/hypertext-transfer-protocol-http/http-request-headers.png)\n- (optional) HTTP body\n    - The body of a request is the part that contains the \u2018body\u2019 of information the request is transferring. The body of an HTTP request contains any information being submitted to the web server, such as a username and password, or any other data entered into a form.\n\nA typical HTTP response contains:\n- HTTP status code\n    - Indicates the status of the request to the client device. Responses may indicate success, an informational response, a redirect, or errors on the server or client side.\n        - Informational responses (100 \u2013 199)\n        - Successful responses (200 \u2013 299)\n        - Redirection messages (300 \u2013 399)\n        - Client error responses (400 \u2013 499)\n        - Server error responses (500 \u2013 599)\n- Response header\n    - Send information about the server and requested resources\n- (optional) HTTP body\n    - If a request is successful, this contains the requested data in the form of HTML code, which is translated into a web page by the client browser\n\n\n\n[credit1](https://www.cloudflare.com/learning/ddos/glossary/hypertext-transfer-protocol-http/) [credit2](https://doc.oroinc.com/api/http-methods/#:~:text=The%20primary%20or%20most%20commonly,or%20CRUD%20operations%2C%20respectively) [credit3](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)\n\n## HTTPS (Hypertext Transfer Protocol Secure)\nHypertext transfer protocol secure (HTTPS) is the secure version of HTTP, which is the primary protocol used to send data between a web browser and a website. HTTPS is encrypted in order to increase security of data transfer. This is particularly important when users transmit sensitive data, such as by logging into a bank account, email service, or health insurance provider.\n\nHTTPS uses an encryption protocol to encrypt communications. The protocol is called Transport Layer Security (TLS), although formerly it was known as Secure Sockets Layer (SSL). This protocol secures communications by using what\u2019s known as an asymmetric public key infrastructure. This type of security system uses two different keys to encrypt communications between two parties:\n- Private key\n    - This key is controlled by the owner of a website and it\u2019s kept, as the reader may have speculated, private. This key lives on a web server and is used to decrypt information encrypted by the public key\n- Public key\n    - This key is available to everyone who wants to interact with the server in a way that\u2019s secure. Information that\u2019s encrypted by the public key can only be decrypted by the private key.\n### SSL (Secure Sockets Layer)\nSSL, or Secure Sockets Layer, is an encryption-based Internet security protocol. It was first developed by Netscape in 1995 for the purpose of ensuring privacy, authentication, and data integrity in Internet communications. SSL is the predecessor to the modern TLS encryption used today.\n\nIf a site has `https` in it's URL, it implemented SSL/TLS\n\nHow does it work?\n- In order to provide a high degree of privacy, SSL encrypts data that is transmitted across the web. This means that anyone who tries to intercept this data will only see a garbled mix of characters that is nearly impossible to decrypt.\n- SSL initiates an authentication process called a handshake between two communicating devices (your computer & the website's server) to ensure that both devices are really who they claim to be.\n- SSL also digitally signs data in order to provide data integrity, verifying that the data is not tampered with before reaching its intended recipient.\n\n#### What is an SSL certificate?\nSSL certificates make SSL/TLS encryption possible, and they contain the website's public key and the website's identity, along with related information. Devices attempting to communicate with the origin server will reference this file to obtain the public key and verify the server's identity. The private key is kept secret and secure.\n\nWhat does the SSL certificate contain?\n- The domain name that the certificate was issued for\n- Which person, organization, or device it was issued to\n- Which certificate authority issued it\n- The certificate authority's digital signature\n- Associated subdomains\n- Issue date of the certificate\n- Expiration date of the certificate\n- The public key (the private key is kept secret)\n\nHow does a website obtain an SSL certificate?\n- For an SSL certificate to be valid, domains need to obtain it from a certificate authority (CA). A CA is an outside organization, a trusted third party, that generates and gives out SSL certificates. The CA will also digitally sign the certificate with their own private key, allowing client devices to verify it. Once the certificate is issued, it needs to be installed and activated on the website's origin server.\n\n\"Self-signed SSL certificates are a thing, why does it still say my website is insecure?\"\n- Technically, anyone can create their own SSL certificate by generating a public-private key pairing and including all the information mentioned above. Such certificates are called self-signed certificates because the digital signature used, instead of being from a CA, would be the website's own private key.\n- But with self-signed certificates, there's no outside authority to verify that the origin server is who it claims to be. Browsers don't consider self-signed certificates trustworthy and may still mark sites with one as \"not secure,\" despite the https:// URL. They may also terminate the connection altogether, blocking the website from loading.\n\n\n[credit1](https://www.cloudflare.com/learning/ssl/what-is-ssl/)\n\n### TLS (Transport Layer Security)\nSSL and TLS are essentially the same thing, just remember TLS is the *new* and SSL is the *old*.\n\n#### What happens in a TLS handshake?\nDuring the course of a TLS handshake, the client and server together will do the following:\n\n1. Specify which version of TLS (TLS 1.0, 1.2, 1.3, etc.) they will use\n2. Decide on which cipher suites (see below) they will use\n3. Authenticate the identity of the server via the server\u2019s public key and the SSL certificate authority\u2019s digital signature\n4. Generate session keys in order to use symmetric encryption after the handshake is complete\n\nThe steps of a TLS handshake include:\n1. The SSL or TLS client sends a \u201cclient hello\u201d message that lists cryptographic information such as the SSL or TLS version and, in the client's order of preference, the CipherSuites supported by the client. The message also contains a random byte string that is used in subsequent computations. The protocol allows for the \u201cclient hello\u201d to include the data compression methods supported by the client.\n2. The SSL or TLS server responds with a \u201cserver hello\u201d message that contains the CipherSuite chosen by the server from the list provided by the client, the session ID, and another random byte string. The server also sends its digital certificate. If the server requires a digital certificate for client authentication, the server sends a \u201cclient certificate request\u201d that includes a list of the types of certificates supported and the Distinguished Names of acceptable Certification Authorities (CAs).\n3. The SSL or TLS client verifies the server's digital certificate.\n4. The SSL or TLS client sends the random byte string that enables both the client and the server to compute the secret key to be used for encrypting subsequent message data. The random byte string itself is encrypted with the server's public key.\n5. If the SSL or TLS server sent a \u201cclient certificate request\u201d, the client sends a random byte string encrypted with the client's private key, together with the client's digital certificate, or a \u201cno digital certificate alert\u201d. This alert is only a warning, but with some implementations the handshake fails if client authentication is mandatory.\n6. The SSL or TLS server verifies the client's certificate.\n7. The SSL or TLS client sends the server a \u201cfinished\u201d message, which is encrypted with the secret key, indicating that the client part of the handshake is complete.\n8. The SSL or TLS server sends the client a \u201cfinished\u201d message, which is encrypted with the secret key, indicating that the server part of the handshake is complete.\n9. For the duration of the SSL or TLS session, the server and client can now exchange messages that are symmetrically encrypted with the shared secret key.\n\n[Another good article to read about the TLS handshake](https://levelup.gitconnected.com/deep-dive-into-tls-handshake-e029e28e2eb3)\n\n![img](https://www.ibm.com/docs/en/SSFKSJ_7.5.0/com.ibm.mq.sec.doc/q009930a.gif)\n\n[credit1](https://www.cloudflare.com/learning/ssl/what-is-https/) [credit2](https://www.ibm.com/docs/en/ibm-mq/7.5?topic=ssl-overview-tls-handshake)\n\n\n# DNS (Domain Name System)\nThe Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.\n\nEach device connected to the Internet has a unique IP address which other machines use to find the device. DNS servers eliminate the need for humans to memorize IP addresses such as 192.168.1.1 (in IPv4), or more complex newer alphanumeric IP addresses such as 2400:cb00:2048:1::c629:d7a2 (in IPv6).\n\n## 4 DNS servers\n1. DNS Recursor\n    - The recursor can be thought of as a librarian who is asked to go find a particular book somewhere in a library. The DNS recursor is a server designed to receive queries from client machines through applications such as web browsers. Typically the recursor is then responsible for making additional requests in order to satisfy the client\u2019s DNS query.\n2. Root Nameserver\n    - The root server is the first step in translating (resolving) human readable host names into IP addresses. It can be thought of like an index in a library that points to different racks of books - typically it serves as a reference to other more specific locations.\n3. TLD Nameserver\n    - The top level domain server (TLD) can be thought of as a specific rack of books in a library. This nameserver is the next step in the search for a specific IP address, and it hosts the last portion of a hostname (In example.com, the TLD server is \"com\").\n4. Authoritative Nameserver\n    - This final nameserver can be thought of as a dictionary on a rack of books, in which a specific name can be translated into its definition. The authoritative nameserver is the last stop in the nameserver query. If the authoritative name server has access to the requested record, it will return the IP address for the requested hostname back to the DNS Recursor (the librarian) that made the initial request.\n\n## Sequence\n![img](https://cf-assets.www.cloudflare.com/slt3lc6tev37/1NzaAqpEFGjqTZPAS02oNv/bf7b3f305d9c35bde5c5b93a519ba6d5/what_is_a_dns_server_dns_lookup.png)\n\n![img](https://imgur.com/3ezXzsX.jpg)\n\n[![video](https://img.youtube.com/vi/27r4Bzuj5NQ/0.jpg)](https://www.youtube.com/watch?v=27r4Bzuj5NQ)\n\n[credit1](https://www.cloudflare.com/learning/dns/what-is-dns/)\n\n# FTP (File Transfer Protocol)\nThe term file transfer protocol (FTP) refers to a process that involves the transfer of files between devices over a network.\n\nMost web browsers come with FTP clients that enable users to transfer files from their computer to a server and vice versa. Some users may want to use a third-party FTP client because many of them offer extra features. Examples of FTP clients that are free to download include FileZilla Client, FTP Voyager, WinSCP, CoffeeCup Free FTP, and Core FTP.\n\nMany people have used FTP before without even realizing it. If you have ever downloaded a file from a web page, you've used FTP. The first step is to log in, which may occur automatically or by manually inputting a username and password. FTP will also require you to access an FTP server through a specific port number. Once you access the FTP server through your FTP client, you can now transfer files. Not all public FTP servers require you to sign in because some servers enable you to access them anonymously.\n\n[credit1](https://www.investopedia.com/terms/f/ftp-file-transfer-protocol.asp)\n\n# SSH (Secure Shell)\nSSH, also known as Secure Shell or Secure Socket Shell, is a network protocol that gives users, particularly system administrators, a secure way to access a computer over an unsecured network.\n\nAn SSH server, by default, listens on the standard Transmission Control Protocol (TCP) port 22.\n\nConnecting to a server: `ssh -v nishant@123.456.789.100`\n\nOther executable commands related to SSH:\n- `sshd`\n    - initiates the SSH server, which waits for incoming SSH connection requests and enables authorized systems to connect to the local host\n- `ssh-keygen`\n    - is a program to create a new authentication key pair for SSH, which can be used to automate logins, to implement SSO and to authenticate hosts\n- `ssh-copy-id`\n    - is a program used to copy, install and configure an SSH key on a server to automate passwordless logins and SSO.\n- `ssh-agent`\n    - is a helper program that tracks identity keys and their passphrases -- from which SSH derives an encryption key -- and enables the user to use the identity keys to log in to different servers without the need to reenter passwords or passphrases.\n- `ssh-add`\n    - is used to add a key to the SSH authentication agent and is used with ssh-agent to implement SSO using SSH.\n- `scp`\n    - is a program used for copying files from one computer to another and is an SSH-secured version of rcp.\n- `sftp`\n    - is a program used to copy files from one computer to another and is an SSH-secured version of ftp, the original File Transfer Protocol. SFTP has become the preferred mechanism for file sharing over the internet, replacing both FTP and FTP/S (FTP Secure), which is a protocol for using FTP over an SSL/TLS tunnel.\n\n[credit1](https://www.techtarget.com/searchsecurity/definition/Secure-Shell) [credit2](https://www.ssh.com/academy/ssh/tunneling-example)\n\n[apparently this book is a good resource for tunneling, haven't checked it out myself *yet*, but will in the future](https://www.amazon.com/SSH-Mastery-OpenSSH-PuTTY-Tunnels/dp/1642350028)\n\n\n\n# DHCP (Dynamic Host Configuration Protocol)\nDHCP (Dynamic Host Configuration Protocol) is a network management protocol used to dynamically assign an IP address to any device, or node, on a network so it can communicate using IP. DHCP automates and centrally manages these configurations rather than requiring network administrators to manually assign IP addresses to all network devices. DHCP can be implemented on small local networks, as well as large enterprise networks.\n\n## How DHCP works\nIt dynamically assigns IP addresses to DHCP clients and allocates TCP/IP configuration information to DHCP clients. This information includes subnet mask information, default gateway IP addresses and domain name system (DNS) addresses.\n\nDHCP is a client-server protocol in which servers manage a pool of unique IP addresses, as well as information about client configuration parameters. The servers then assign addresses out of those address pools. DHCP-enabled clients send a request to the DHCP server whenever they connect to a network.\n\nClients configured with DHCP broadcast a request to the DHCP server and request network configuration information for the local network to which they're attached. A client typically broadcasts a query for this information immediately after booting up. The DHCP server responds to the client request by providing IP configuration information previously specified by a network administrator. This includes a specific IP address, as well as a time period -- also called a lease -- for which the allocation is valid.\n\nWhen refreshing an address assignment, a DHCP client requests the same parameters, but the DHCP server may assign a new IP address based on policies set by administrators. DHCP clients can also be configured on an Ethernet interface.\n\nA DHCP server manages a record of all the IP addresses it allocates to network nodes. If a node is relocated in the network, the server identifies it using its media access control (MAC) address, which prevents the accidental configuration of multiple devices with the same IP address. Configuring a DHCP server also requires the creation of a configuration file, which stores network information for clients.\n\nDHCP is not a routable protocol, nor is it a secure one. DHCP is limited to a specific local area network, which means a single DHCP server per LAN is adequate -- or two servers for use in case of a failover. Larger networks might have a wide area network (WAN) that contains multiple individual locations. Depending on the connections between these points and the number of clients in each location, multiple DHCP servers can be set up to handle the distribution of addresses.\n\nIf network administrators want a DHCP server to provide addressing to multiple subnets on a given network, they must configure DHCP relay services located on interconnecting routers that DHCP requests have to cross. These agents relay messages between DHCP clients and servers located on different subnets.\n\nDHCP lacks any built-in mechanism that enables clients and servers to authenticate each other. Both are vulnerable to deception -- one computer pretending to be another -- and to attack, where rogue clients can exhaust a DHCP server's IP address pool.\n\n## Components\nThe DHCP server -- typically either a server or router -- is a networked device that runs on the DHCP service. The DHCP server holds IP addresses, as well as related information pertaining to configuration.\n\nThe DHCP client is a device -- such as a computer or phone -- that connects to a network and communicates with a DHCP server.\n\nThe DHCP relay manages requests between DHCP clients and servers. Typically, relays are used when an organization has to handle large or complex networks.\n\n[credit1](https://www.techtarget.com/searchnetworking/definition/DHCP)\n\n## Static vs Dynamic\nWith dynamic DHCP, a client does not own the IP address assigned to it but instead leases it for a period of time. Each time a device with a dynamic IP address is powered up, it must communicate with the DHCP server to lease another IP address. Wireless devices are examples of clients that are assigned dynamic IP addresses when they connect to a network.\n\nOn the other hand, static devices -- such as web servers and switches -- are assigned permanent IP addresses.\n\n# LDAP (Lightweight Directory Access Protocol)\nLDAP (Lightweight Directory Access Protocol) is a software protocol for enabling anyone to locate data about organizations, individuals and other resources such as files and devices in a network -- whether on the public internet or a corporate intranet.\n\nA directory tells the user where in the network something is located. On TCP/IP networks -- including the internet -- the domain name system (DNS) is the directory system used to relate the domain name to a specific network address, which is a unique location on the network. However, the user may not know the domain name. LDAP allows a user to search for an individual without knowing where they're located, although additional information will help with the search.\n\nThe most common use of LDAP is to provide a central place for authentication, meaning it stores usernames and passwords. LDAP can then be used in different applications or services to validate users with a plugin. For example, LDAP can be used to validate usernames and passwords with Docker, Jenkins, Kubernetes, OpenVPN and Linux Samba servers. System administrators can also use LDAP single sign-on to control access to an LDAP database.\n\nLDAP can also be used to add operations into a directory server database, authenticate -- or \"bind\" -- sessions, delete LDAP entries, search and compare entries using different commands, modify existing entries, extend entries, abandon requests or unbind operations.\n\n## LDAP and Active Directory\nLightweight Directory Access Protocol is the protocol that Exchange Server uses to communicate with Active Directory. To really understand what LDAP is and what it does, it is important to understand the basic concept behind Active Directory as it relates to Exchange.\n\nActive Directory is a directory service for managing domains, users and distributed resources such as objects for Windows operating systems. A directory service manages domains and objects while controlling which users have access to each resource. Active Directory is available on Windows Server 2022 and is comprised of multiple services. Services included in Active Directory are Domain, Lightweight Directory, Certificate, Federation and Rights Management services. Each service is included under the Active Directory name to expand directory management capabilities. Active Directory was first previewed in 1999 and has continued to receive updates since then -- including an update with Windows Server 2016 that improved secure Active Directory environments and the ability to migrate Active Directory environments to cloud or hybrid cloud environments.\n\nActive Directory contains information regarding every user account on an entire network. It treats each user account as an object. Each user object also has multiple attributes. An example of an attribute is the user's first name, last name or e-mail address. All this information exists within a huge, cryptic database on a domain controller -- Active Directory. The challenge is to extract information in a usable format. This is LDAP's main job.\n\nLDAP uses a relatively simple, string-based query to extract information from Active Directory. LDAP can store and extract objects such as usernames and passwords in Active Directory and share that object data throughout a network. The nice part is that this all happens behind the scenes. A regular end user will never have to manually perform an LDAP query because Outlook is LDAP-enabled and knows how to perform all the necessary queries on its own.\n\n## LDAP Authentication Process\nConsists of the following key players:\n- Directory System Agent (DSA)\n    - Server running LDAP on its network\n- Directory User Agent (DUA)\n    - Accesses DSAs as a client (ex: user's PC)\n- Distinguished Name (DN)\n    - COntains a path through the directory information tree for LDAP to navigate through (ex: cn=Nishant, ou=users, o=Company)\n- Relative Distinguished Name (RDN)\n    - Each component in the path within the DN\n- Application Programming Interface (API)\n    - A service that lets your app utilize LDAP without knowing the underlying architecture\n\n[credit1](https://www.techtarget.com/searchmobilecomputing/definition/LDAP)", "02. OSI Model.md": "The Open Systems Interconnection (OSI) model describes seven layers that computer systems use to communicate over a network\n\nThe modern Internet is not based on OSI, but on the simpler TCP/IP model. However, the OSI 7-layer model is still widely used, as it helps visualize and communicate how networks operate, and helps isolate and troubleshoot networking problems.\n\n# 7 layers\nThe seven layers include:\n\n(bottom)\n\n1. Physical Layer\n    1. The physical layer is responsible for the physical cable or wireless connection between network nodes. It defines the connector, the electrical cable or wireless technology connecting the devices, and is responsible for transmission of the raw data, which is simply a series of 0s and 1s, while taking care of bit rate control.\n    2. Barebones hardware/physical connection between devices\n2. Data Link Layer\n    1. The data link layer establishes and terminates a connection between two physically-connected nodes on a network. It breaks up packets into frames and sends them from source to destination. This layer is composed of two parts\u2014Logical Link Control (LLC), which identifies network protocols, performs error checking and synchronizes frames, and Media Access Control (MAC) which uses MAC addresses to connect devices and define permissions to transmit and receive data.\n    2. Transfers data across network media\n3. Network Layer\n    1. The network layer has two main functions. One is breaking up segments into network packets, and reassembling the packets on the receiving end. The other is routing packets by discovering the best path across a physical network. The network layer uses network addresses (typically Internet Protocol addresses) to route packets to a destination node.\n    2. Addresses data and delivers in between networks\n4. Transport Layer\n    1. The transport layer takes data transferred in the session layer and breaks it into \u201csegments\u201d on the transmitting end. It is responsible for reassembling the segments on the receiving end, turning it back into data that can be used by the session layer. The transport layer carries out flow control, sending data at a rate that matches the connection speed of the receiving device, and error control, checking if data was received incorrectly and if not, requesting it again.\n    2. Manages data transfers and checks transmitted data is the same as received data\n5. Session Layer\n    1. The session layer creates communication channels, called sessions, between devices. It is responsible for opening sessions, ensuring they remain open and functional while data is being transferred, and closing them when communication ends. The session layer can also set checkpoints during a data transfer\u2014if the session is interrupted, devices can resume data transfer from the last checkpoint.\n    2. Manages connections and terminations between connected computers\n6. Presentation Layer\n    1. The presentation layer prepares data for the application layer. It defines how two devices should encode, encrypt, and compress data so it is received correctly on the other end. The presentation layer takes any data transmitted by the application layer and prepares it for transmission over the session layer.\n    2. Makes sure that the information is presented in a format that the device can understand\n7. Application Layer\n    1. The application layer is used by end-user software such as web browsers and email clients. It provides protocols that allow software to send and receive information and present meaningful data to users. A few examples of application layer protocols are the Hypertext Transfer Protocol (HTTP), File Transfer Protocol (FTP), Post Office Protocol (POP), Simple Mail Transfer Protocol (SMTP), and Domain Name System (DNS).\n    2. Home of the protocols and services that comprise an application\n\n(top)\n\nGraphical view:\n\n![img](https://www.imperva.com/learn/wp-content/uploads/sites/13/2020/02/OSI-7-layers.jpg)\n\n\n# OSI Model vs TCP/IP Model\n![img](https://www.imperva.com/learn/wp-content/uploads/sites/13/2020/02/OSI-vs.-TCPIP-models.jpg)\n\n\n# Handy Mnemonic\nPlease Do Not Teach Stupid People Acronyms\n\n[credit1](https://www.imperva.com/learn/application-security/osi-model/#:~:text=SecurityEssentialsProtocols-,What%20Is%20the%20OSI%20Model,companies%20in%20the%20early%201980s) [credit2](https://www.comparitech.com/net-admin/osi-model-explained/)", "03. What happens when you visit a site.md": "# Introduction\nNowadays, visiting websites is as easy as typing in a URL into your preferred browser and hitting enter, but do you know what happens in the background? Hopefully, if you've been following along with the `01. Protocols` document, you'll realize that some of the key components of routing things back to your computer are mentioned there.\n\nRegardless, below are the *steps*:\n\nWe'll be utilizing the URL address of the homepage for our application: `https://1sre.io/manual`\n\n# Breakdown\nWhen you enter `https://1sre.io/manual`, there are four components to look at\n\n## Scheme\n`https://` is the scheme of our URL. As mentioned in `01. Protocols`, \"Hypertext transfer protocol secure (HTTPS) is the secure version of HTTP, which is the primary protocol used to send data between a web browser and a website.\" This scheme tells the browser to make a connection to the server utilizing TLS (or SSL, remember, TLS is the *new*!).\n\n## Domain\n`1sre.io` is the domain of the site. It's easier to remember than the specific IP address (insert IP address later). So how does the broswer know where to pull the IP address from? If you said the DNS, you're right! As mentioned in `01. Protocols`, \"The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.\".\n\n## Path\nThe path is what comes after `1sre.io/`, so in this instance, it's `manual`. You can think of the path like the directory system. Common examples of paths are `blog`, `posts`, `tags`, or `images`, each grouping different resources.\n\n## Resource\nIn theory, there's a resource that we're hitting when we get to that URL. Sometimes you'll see a file extension like `.html` which indicates that the source is a static file on the server with HTML content. If there is no extension, it usually indicates that the server generated the content.\n\n# IP Look up\nWhen hitting `https://1sre.io/manual`, the browser hits a DNS service like Cloudflare's or Google's Public DNS.\n\nThere are four components of the DNS endpoint:\n1. DNS Recursor\n    - The recursor can be thought of as a librarian who is asked to go find a particular book somewhere in a library. The DNS recursor is a server designed to receive queries from client machines through applications such as web browsers. Typically the recursor is then responsible for making additional requests in order to satisfy the client\u2019s DNS query.\n2. Root Nameserver\n    - The root server is the first step in translating (resolving) human readable host names into IP addresses. It can be thought of like an index in a library that points to different racks of books - typically it serves as a reference to other more specific locations.\n3. TLD Nameserver\n    - The top level domain server (TLD) can be thought of as a specific rack of books in a library. This nameserver is the next step in the search for a specific IP address, and it hosts the last portion of a hostname (In example.com, the TLD server is \"com\").\n4. Authoritative Nameserver\n    - This final nameserver can be thought of as a dictionary on a rack of books, in which a specific name can be translated into its definition. The authoritative nameserver is the last stop in the nameserver query. If the authoritative name server has access to the requested record, it will return the IP address for the requested hostname back to the DNS Recursor (the librarian) that made the initial request.\n\nTypically, most websites you encounter will be cached somewhere in the DNS process. Rather than restating everything mentioned in the `01. Protocols` article, check out the images and video below:\n![img](https://cf-assets.www.cloudflare.com/slt3lc6tev37/1NzaAqpEFGjqTZPAS02oNv/bf7b3f305d9c35bde5c5b93a519ba6d5/what_is_a_dns_server_dns_lookup.png)\n\n![img](https://imgur.com/3ezXzsX.jpg)\n\n[![video](https://img.youtube.com/vi/27r4Bzuj5NQ/0.jpg)](https://www.youtube.com/watch?v=27r4Bzuj5NQ)\n\n# TCP Connection\nYour browser utilizes a TCP connection with the website's server so it can communicate securely over the internet. Using the public Internet routing infrastructure, packets from a client browser request get routed through the router, the ISP, through an internet exchange to switch ISPs or networks, all using transmission control protocol, more commonly known as TCP, to find the server with the IP address to connect to.\n\nWhen the three-way-handshake is made between the client and the server, the next step is to send the HTTP request to get the page.\n\n# HTTP Request\nIf you look at the network console when vising `https://1sre.io/manual`, you'll see a bunch of requests being made. Most of the requests will be `GET` requests to retrieve the necessary information for the particular webpage.\n\nThe server then responds with a `200 OK` (assuming nothing went wrong with the server) and sends back a response for the client to work with; in this case, it's going to be a JSON data for the website to pull text from.\n\n# Conclusion\nAfter receiving the response from the server, the client (browser) renders the content and makes any additional requets to  get JavaScript, CSS, images, and other kinds of content to produce the rest of the webpage.\n\n\n[credit1](https://tinyurl.com/3syumskj)"}, "02. Operating Systems": {"01. Linux": {"01. RHEL": {"01. RHCSA": {"01. Introduction.md": "## Training\nIf possible, please get your training straight from Red Hat as opposed to utilizing a third party-- this is assuming you're okay with virtual self-paced training; it's easier on a company's training budget.\n\nYou can find more information about it [here](https://www.redhat.com/en/services/training/learning-subscription). If possible, go for the premium option.\n\nIf you're fine with virtual self-paced training, this approach of training alongside RH makes the most sense and has the best bang for the buck. As opposed to paying $4000 for one RHCSA week-long training, you have access to all of the trainings provided by Red Hat for $9000-- and all the training + tests is up to **you** (don't forget about the free retakes)!\n\n## Notice\nAll of the content found in this subfolder is either work that I completed during the RHCSA training or training material given to me; I do not plan on updating any of the files moving forward past the RHCSA certification."}, "01. Why?.md": "Because it's emphasized at work.\n\nAlso, apparently getting a certification in RHEL is a good choice overall as it makes you \"more marketable\".\n\nAt the time of writing this, my plan is to obtain the RHCSA, RHCSE, and Ansible (OpenShift too, but for other reasons) certs from Red Hat."}, "03. Boot Sequence.md": "There are 6 distinct stages in a typical Linux boot process:\n\n1. BIOS (Basic Input/Output System)\n2. MBR (Master Boot Record)\n3. GRUB (GNU GRand Unified Bootloader)\n4. Kernel\n5. Init\n6. Runlevel programs\n\nBelow is a detailed description of each stage [credit](https://www.freecodecamp.org/news/the-linux-booting-process-6-steps-described-in-detail/)\n1. BIOS (Basic Input/Output System) - **INDEPENDENT OF OS, HAPPENS ON EVERY OS**\n    - The BIOS loads and executes the MBR\n    - When you first turn on your computer, the BIOS performs some integrity checks for the HDD (hard-disk drive) or SSD (solid-state drive)\n    - BIOS runs from ROM (read only memory) which comes from the motherboard\n    - Next, the BIOS searches for, loads, and executes the boot loader program which is found in the MBR (often on a USB stick, CD-ROM, or HDD/SSD)\n    - Once the boot loader is detected, it's loaded into memory and the BIOS gives control to the system\n\n    Example of BIOS\n\n    ![img](https://www.groovypost.com/wp-content/uploads/2015/08/3-Install-Device-Moved-Up-in-Boot-Priority-BIOS.png)\n2. MBR (Master Boot Record)\n    - Responsible for loading and executing the GRUB boot loader\n    - \n    - The MBR is located in the 1st sector of the bootable disk, which is typically `/dev/hda` or `/dev/sda` depending on the hardware. It also contains information about the GRUB\n3. GRUB (GNU GRand Unified Bootloader)\n    - This is the typical boot loader for most modern Linux systems\n    - GRUB will run in RAM (random access memory)\n    - The GRUB splash screen is often the first thing you see when you boot your computer. It has a simple menu where you can select some options. If you have multiple kernel images installed, you can use your keyboard to select the one you want your system to boot with. By default, the latest kernel image is selected.\n    - Example:\n        - If you dual boot your system (two OS such as RHEL9 and Windows 10), the GRUB menu will give you the option of choosing either RHEL9 or Windows 10\n    - The splash screen will wait a few seconds for you to select and option. If you don't, it will load the default kernel image.\n    - In many systems you can find the GRUB configuration file at `/boot/grub/grub.conf` or `/etc/grub.conf`\n    - Main purpose of GRUB is to load kernel into RAM (memory)\n\n    Example of GRUB Screen\n    ![img](https://itsfoss.com/content/images/wordpress/2019/12/grub_screen.png)\n4. Kernel\n    - Core of any OS\n    - In this stage of the boot process, the kernel that was selected by GRUB first mounts the root file system that's specified in the `grub.conf` file. Then it executes the `/sbin/init program`, which is always the first program to be executed. You can confirm this with its process id (PID), which should always be 1.\n    - The kernel then establishes a temporary root file system using Initial RAM Disk (initrd) until the real file system is mounted.\n5. Init (Initilization) [credit](https://www.thegeekstuff.com/2011/02/linux-boot-process/)\n    - Parent process (`ps -aux`).. you'll see it has a PID of 1\n    - At this point, your system executes runlevel programs. At one point it would look for an init file, usually found at `/etc/inittab` to decide the Linux run level.\n    - Following are available run levels\n        - 0 -> Halt\n        - 1 -> Single user mode\n        - 2 -> Multiuser, without NFS (network file system)\n        - 3 -> Full multiuser mode (command line interface and not under the graphical user interface) (typically set to this..)\n        - 4 -> Unused\n        - 5 -> X11 (multiple user mode under graphical user interface) (..or typically set to this)\n        - 6 -> Reboot\n    - Init identifies the default initlevel from /etc/inittab and uses that to load all appropriate program\n    - Execute `grep initdefault /etc/inittab` on your system to identify the default run level\n    \n    Proof that `/init` has a PID of 1..\n    ![img](https://prnt.sc/lAyObB3ygEYR)\n6. Runlevel programs [credit](https://www.thegeekstuff.com/2011/02/linux-boot-process/#:~:text=Programs%20starts%20with,started%20before%20sendmail.)\n    - When the Linux system is booting up, you might see various services getting started. For example, it might say `\"starting sendmail... OK\"`. Those are the runlevel programs, executed from the run level directory as defined by your run level.\n    - Depending on your default init level setting, the system will execute the programs from one of the following directories.\n        - Run level 0 \u2013 /etc/rc.d/rc0.d/\n        - Run level 1 \u2013 /etc/rc.d/rc1.d/\n        - Run level 2 \u2013 /etc/rc.d/rc2.d/\n        - Run level 3 \u2013 /etc/rc.d/rc3.d/\n        - Run level 4 \u2013 /etc/rc.d/rc4.d/\n        - Run level 5 \u2013 /etc/rc.d/rc5.d/\n        - Run level 6 \u2013 /etc/rc.d/rc6.d/\n    - Programs starts with S are used during startup. S for startup.\n    - Programs starts with K are used during shutdown. K for kill.\n    - There are numbers right next to S and K in the program names. Those are the sequence number in which the programs should be started or killed.\n    - For example, S12syslog is to start the syslog deamon, which has the sequence number of 12. S80sendmail is to start the sendmail daemon, which has the sequence number of 80. So, syslog program will be started before sendmail.\n", "04. Symbolic Links.md": "A symbolic link, also known as a symlink or soft link, is a special type of file that points to another file or directory.\n\n# Link Types\n## Hard Links\nYou can think a hard link as an additional name for an existing file. Hard links are associating two or more file names with the same inode. You can create one or more hard links for a single file. Hard links cannot be created for directories and files on a different filesystem or partition.\n\n## Soft Links\nA soft link is something like a shortcut in Windows. It is an indirect pointer to a file or directory. Unlike a hard link, a symbolic link can point to a file or a directory on a different filesystem or partition.\n\n# `ln` command\n`ln` is a command-line utility for creating links between files. By default, the `ln` command creates hard links. To create a symbolic link, use the `-s` (`--symbolic`) option\n\nThe `ln` command syntax for creating symbolic links is as follows:\n```\nln -s [OPTIONS] FILE LINK\n```\n- If both the `FILE` and `LINK` are given, `ln` will create a link from the file specified as the first argument (`FILE`) to the file specified as the second argument (`LINK`).\n- If only one file is given as an argument or the second argument is a dot (`.`), ln will create a link to that file in the current working directory. The name of the symlink will be the same as the name of the file it points to\n\n# Simplicity\nBasically, think of this has shortcuts\n\n[credit1](https://linuxize.com/post/how-to-create-symbolic-links-in-linux-using-the-ln-command/)", "01. What is Linux?.md": "- Open source\n- In many ways, Linux is similar to other operating systems you may have used before, such as Windows, macOS (formerly OS X), or iOS. Like other operating systems, Linux has a graphical interface, and the same types of software you are accustomed to, such as word processors, photo editors, video editors, and so on. In many cases, a software\u2019s creator may have made a Linux version of the same program you use on other systems. In short: if you can use a computer or other electronic device, you can use Linux. [credit](https://opensource.com/resources/linux)\n\n- But Linux also is different from other operating systems in many important ways. First, and perhaps most importantly, Linux is open source software. The code used to create Linux is free and available to the public to view, edit, and\u2014for users with the appropriate skills\u2014to contribute to. [credit](https://opensource.com/resources/linux)\n\n- Linux is also different in that, although the core pieces of the Linux operating system are generally common, there are many distributions of Linux, which include different software options. This means that Linux is incredibly customizable, because not just applications, such as word processors and web browsers, can be swapped out. Linux users also can choose core components, such as which system displays graphics, and other user-interface components. [credit](https://opensource.com/resources/linux)\n\n# Unix vs Linux?\nI've heard of both Unix and Linux, so what the heck is the difference and why are they brought up?\n- Linux is an open-source operating system. This OS is supported on several computer platforms and includes multiple software features that handle computer resources, and allow you to do tasks. This operating system was launched by Linus Torvalds at the University of Helsinki in 1991. [credit](https://byjus.com/gate/difference-between-unix-and-linux/#:~:text=Basic%20Definition-,Linux%20is%20an%20open%2Dsource%20operating%20system.,the%20user%20and%20the%20computer.)\n\n- Unix is a powerful and multitasking operating system that behaves like a bridge between the user and the computer. It allows the user to perform specific functions. This operating system was launched in 1960, and was released by AT&T Bell Labs. [credit](https://byjus.com/gate/difference-between-unix-and-linux/#:~:text=Basic%20Definition-,Linux%20is%20an%20open%2Dsource%20operating%20system.,the%20user%20and%20the%20computer.)\n\nAlas, there's nothing to really be concerned about. Just remember: [Linux refers to the kernel of the GNU/Linux operating system. More generally, it refers to the family of derived distributions](https://www.softwaretestinghelp.com/unix-vs-linux/#Difference_Between_Unix_and_Linux) and [Unix refers to the original operating system developed by AT&T. More generally, it refers to family of derived operating systems.](https://www.softwaretestinghelp.com/unix-vs-linux/#Difference_Between_Unix_and_Linux)\n\nLinux was designed considering UNIX compatability; it's functionality list is quite similar to that of UNIX [credit](https://www.tutorialspoint.com/operating_system/os_linux.htm)", "06. Other stuff.md": "links\ninodes\nthreads", "02. Linux architecture.md": "You can break the Linux system architecture into several components; however, the main ones are: hardware, kernel, system libraries, system utilities, desktop environment, and applications layer.\n\n- Hardware layer\n    - Represents the physical hardware components of the computer such as the CPU, memory, and storage.\n- Kernel layer\n    - The kernel is one of the major sections of an OS (operating system). It's responsible for each of the major actions of the Linux OS; the kernel facilitates required abstraction for hiding details of low-level hardware or application programs to the system [credit](https://www.javatpoint.com/architecture-of-linux). Below are some important kernel types which will be referred to later\n        - Monolithic kernel\n        - Micro kernels\n        - Exo kernels\n        - Hybrid kernels\n        - Nano kernels\n    - Ultimately, the kernel is what interacts between the barebone hardware and the rest of the applications found on the OS\n- System libraries layer\n    - These libraries include system calls which invoke kernel functions as well as other functionst hat perform tasks such as file manipulation, networking, and memory management [credit](https://tecadmin.net/tutorial/linux-architecture)\n- System utilities layer\n    - Set of programs that perform various system-level tasks such as managing processes, controlling users accounts, and configuring system settings. These utilities are command-line programs that are ran by the user or by other programs\n- Desktop environment layer (OPTIONAL)\n    - This is optional because it's not available everything (for example, there's the general Ubuntu ISO and there's a Ubuntu server ISO which doesn't have GUI access.. the server is all command-line focused where as the former is an image that you can interact with more physically such as clicking on items)\n- Applications layer\n    - Topmost layer of the Linux architecture and consists of the software or other applications (i.e.: Google Chrome, VS Code, Docker)\n\n![img](https://static.javatpoint.com/linux/images/architecture-of-linux.png)\n\n\n## Hardware Layer - In depth\n- Overview\n    - This is the bottommost layer of the Linux architecture and represents the physical hardware components of the computer, such as the processor, memory, and storage. The hardware layer is responsible for interacting with the various hardware devices and providing access to them for the rest of the operating system. [credit](https://tecadmin.net/tutorial/linux-architecture)\n    - Barebones!\n\n## Kernel Layer - In depth\n- Overview\n    - The Linux\u00ae kernel is the main component of a Linux operating system (OS) and is the core interface between a computer\u2019s hardware and its processes. It communicates between the 2, managing resources as efficiently as possible. The kernel is so named because\u2014like a seed inside a hard shell\u2014it exists within the OS and controls all the major functions of the hardware, whether it\u2019s a phone, laptop, server, or any other kind of computer. [credit](https://www.redhat.com/en/topics/linux/what-is-the-linux-kernel)\n\nThe kernel has four jobs [credit](https://www.redhat.com/en/topics/linux/what-is-the-linux-kernel)\n- Memory management\n    - Keep track of how much memory is used to store what, and where\n- Process management\n    - Determine which processes can use the central processing unit (CPU), when, and for how long\n- Device drivers\n    - Act as mediator/interpreter between the hardware and processes\n- System calls & Security\n    - Receive requests for service from the processes\n\nThe main difference between the types of kernels is the number of address spaces they support\n- Micro kernels\n    - Microkernels have all of their services in the kernel address space. For their communication protocol, microkernels use message passing, which sends data packets, signals and functions to the correct processes. Microkernels also provide greater flexibility than monolithic kernels; to add a new service, admins modify the user address space for a microkernel. Because of their isolated nature, microkernels are more secure than monolithic kernels. They remain unaffected if one service within the address space fails [credit](https://www.techtarget.com/searchdatacenter/definition/kernel)\n- Monolithic kernel\n    - Monolithic kernels are larger than microkernels, because they house both kernel and user services in the same address space. Monolithic kernels use a faster system call communication protocol than microkernels to execute processes between the hardware and software. They are less flexible than microkernels and require more work; admins must reconstruct the entire kernel to support a new service. Monolithic kernels pose a greater security risk to systems than microkernels because, if a service fails, then the entire system shuts down. Monolithic kernels also don't require as much source code as a microkernel, which means they are less susceptible to bugs and need less debugging. [credit](https://www.techtarget.com/searchdatacenter/definition/kernel)\n- Hybrid kernels\n    - Hybrid kernel is a kernel architecture based on a combination of microkernel and monolithic kernel architecture used in computer operating systems. This kernel approach combines the speed and simpler design of monolithic kernel with the modularity and execution safety of microkernel. A hybrid kernel runs some services in the kernel space to reduce the performance overhead of a traditional microkernel, while still running kernel code as servers in the user space. For instance, a hybrid kernel design may keep the virtual files system and bus controllers inside the kernel and the file system drivers and storage drivers as user mode programs outside the kernel. Such a design keeps the performance and design principles of a monolithic kernel. [credit](https://www.techopedia.com/definition/27004/hybrid-kernel)\n- Nano kernels\n    - A nanokernel is a small kernel that offers hardware abstraction, but without system services. Larger kernels are designed to offer more features and manage more hardware abstraction. Modern microkernels lack system services as well, hence, the terms microkernal and nanokernal have become analogous. [credit](https://www.techopedia.com/definition/27005/nano-kernel)\n- Exo kernels\n    - Exokernel is a type of operating system developed at the Massachusetts Institute of Technology that seeks to provide application-level management of hardware resources. The exokernel architecture is designed to separate resource protection from management to facilitate application-specific customization.\n\n## System Libraries Layer - In depth\n- Overview\n    - This layer consists of a set of libraries that provide functions for the applications to use. These libraries include system calls, which are used to invoke kernel functions, as well as other functions that perform tasks such as file manipulation, networking, and memory management. [credit](https://tecadmin.net/tutorial/linux-architecture)\n\n## System Utilities Layer - In depth\n- Overview\n    - This layer consists of a set of programs that perform various system-level tasks, such as managing processes, controlling user accounts, and configuring system settings. These utilities are usually command-line programs that are invoked by the user or by other programs. [credit](https://tecadmin.net/tutorial/linux-architecture)\n\n## Desktop Environment Layer - In depth\n- Overview\n    - This layer is optional and is not present on all Linux systems. It provides a graphical user interface (GUI) that allows users to interact with the operating system using a mouse and keyboard. The most common desktop environments in Linux are Gnome, KDE, and Xfce. [credit](https://tecadmin.net/tutorial/linux-architecture)\n\n## Application Layer - In depth\n- Overview\n    - This is the topmost layer of the Linux architecture and consists of the various applications that run on the operating system. These can be anything from productivity software and games to web browsers and media players. [credit](https://tecadmin.net/tutorial/linux-architecture)"}, "02. Windows": {"01. What is Windows?.md": "I honestly don't plan on touching this unless my current employer requires me to specialize in Windows.\n<br>\nI primarily use this for personal use\n<br>\nIf someone wants to add to this, please feel free \ud83d\ude00"}}, "99. Interview Prep": {"Oracle": {"01. College prep.md": "- deliver results\n- learn be curious\n- earn trust\n- dive deep\n- invent & simplify\n- bias for action\n- have a backbone; disagree and commit\n- ownerhsip\n- insist on high standards\n\n# Questions\n- Q: Installing packages\n    - A: sudo apt-get install <pckgName>\n\n- Q: Uninstalling packages\n    - A: sudo apt remove <pckgName>\n\n- Q: Updating your Ubuntu repositories\n    - A: sudo apt update\n\n- Q: Updating a all packages\n    - A: sudo apt upgrade\n\n- Q: What is a DNS?\n    - A: Domain name system, like the phone book of the internet of domains (all domains have an ip, blah blah)\n\n- Q: OSI Mode - The OSI model describes seven layers that computer systems use to communicate over a network\n    - Application layer\n    - Human-computer interaction layer, where applications can access the network services\n\n    - Presentation Layer\n    - Ensures that data is in a usable format and is where data encryption occurs\n\n    - Session Layer\n    - Maintains connections and is responsible for controlling ports and sessions\n\n    - Transport Layer\n    - Transmits data using transmission protocols including TCP and UDP\n\n    - Network Layer\n    - Decies which physical path the data will take\n\n    - Data Link Layer\n    - Defines the format of data on the network\n\n    - Physical layer\n    - Transmits raw bit stream over the physical medium\n\n- Q: What to do if you can't successfully SSH to a server\n    \n    A: In order to estbalish an SSH connection, you need both a client and the corresponding server-side component. An SSH client is an application you install on teh computer which you'll use to connect (SSH) to another server or computer\n\n    On the server side, there is a component called an SSH Daemon (Demon) which is constantly listening to a specific TCP/IP port for possible client connection requests.\n\n    When you make a connection through a SSH call/request, both the client and the server are exchanging information (identification data)\n    - if credentials are correct then it'll encrypt the connection between the two\n\n    fun fact: default SSH protocol version for SSH server and SSH client communication is version 2\n\n    STEPS:\n    1. We need to make sure both clients have OpenSSH\n        1. OpenSSH is the premier connectivity tool for remote login with the SSH protocol. It encrypts all traffic to eliminate eavesdropping, connection hijacking, and other attacks. In addition, OpenSSH provides a large suite of secure tunneling capabilities, several authentication methods, and sophisticated configuration options.\n    2. Verify that the SSH service is running on both the client and the server\n        1. sudo service ssh status\n        2. If not running, restart it (sudo systemctl restart ssh)\n    3. Thhere could be a cance that SSH daemon (demon) configuration file is messed up so compare it with the base model of it (sudo nano /etc/ssh/sshd_config)\n        1. Any changes require a ssh restrat (sudo service ssh restart)\n    4. Sometimes you'll need the port number (ssh user@ip -p<nmm>)\n    5. Run SSH with more verbosity (ssh -vvv username@host)\n        1. Basically look at the logs in /var/log/auth.log (look for messages that contain sshd)\n\n# NETWORK PROTOCOLS (TCP & UDP)\n\n- TCP (Transmission Control Protocol)\n    - Connection-oriented meaning once a connection has been established, data can be transmitted in two directions\n    - Perfect protocol for transferring images, data files, and web pages\n    - TCP is SLOWER than UDP\n    - More overhead = more space\n    - TCP provides an ordered delivery of data from user to server (and vice versa)\n    - Data sequencing: possible!\n    - Optimal use: HTTPS, HTTP, SMTP, POP, FTP\n    - Stream type: byte stream\n\n- UDP (User Datagram Protocol):\n    - Connectionless protocol\n    - No overhead for opening a connection, maintaining a connection, or terminating a connection; data is continiously sent regardless of if it's being received successfuly or not\n    - Preferred for real-time communications like broadcast or multitask network transmission (so think real-time chatting over the internet)\n    - UDP is FASTER than TCP\n    - Less overhead = less space\n    - UDP is not dedicated to end-to-end communications, nor does it check the readienss of the receiver\n    - Data sequencing: not possible!\n    - Optimal use: video conferencing, streaming, DNS, VoIP\n    - Stream type: message stream\n\n# NETWORK VIRTUALIZATION\n- Abstracting network resources that were traditionally delivered in hardware to software. NV can combine multiple physical networks to one virtual, software-based network, or it can divide one physical network into separate, independent virtual networks.\n- Network virtualization software allows network administrators to move virtual machines across different domains without reconfiguring the network. The software creates a network overlay that can run separate virtual network layers on top of the same physical network fabric "}, "AWS": {"01. College prep.md": "- deliver results\n- learn be curious\n- earn trust\n- dive deep\n- invent & simplify\n- bias for action\n- have a backbone; disagree and commit\n- ownerhsip\n- insist on high standards\n\n# Questions\n- Q: Installing packages\n    - A: sudo apt-get install <pckgName>\n\n- Q: Uninstalling packages\n    - A: sudo apt remove <pckgName>\n\n- Q: Updating your Ubuntu repositories\n    - A: sudo apt update\n\n- Q: Updating a all packages\n    - A: sudo apt upgrade\n\n- Q: What is a DNS?\n    - A: Domain name system, like the phone book of the internet of domains (all domains have an ip, blah blah)\n\n- Q: OSI Mode - The OSI model describes seven layers that computer systems use to communicate over a network\n    - Application layer\n    - Human-computer interaction layer, where applications can access the network services\n\n    - Presentation Layer\n    - Ensures that data is in a usable format and is where data encryption occurs\n\n    - Session Layer\n    - Maintains connections and is responsible for controlling ports and sessions\n\n    - Transport Layer\n    - Transmits data using transmission protocols including TCP and UDP\n\n    - Network Layer\n    - Decies which physical path the data will take\n\n    - Data Link Layer\n    - Defines the format of data on the network\n\n    - Physical layer\n    - Transmits raw bit stream over the physical medium\n\n- Q: What to do if you can't successfully SSH to a server\n    \n    A: In order to estbalish an SSH connection, you need both a client and the corresponding server-side component. An SSH client is an application you install on teh computer which you'll use to connect (SSH) to another server or computer\n\n    On the server side, there is a component called an SSH Daemon (Demon) which is constantly listening to a specific TCP/IP port for possible client connection requests.\n\n    When you make a connection through a SSH call/request, both the client and the server are exchanging information (identification data)\n    - if credentials are correct then it'll encrypt the connection between the two\n\n    fun fact: default SSH protocol version for SSH server and SSH client communication is version 2\n\n    STEPS:\n    1. We need to make sure both clients have OpenSSH\n        1. OpenSSH is the premier connectivity tool for remote login with the SSH protocol. It encrypts all traffic to eliminate eavesdropping, connection hijacking, and other attacks. In addition, OpenSSH provides a large suite of secure tunneling capabilities, several authentication methods, and sophisticated configuration options.\n    2. Verify that the SSH service is running on both the client and the server\n        1. sudo service ssh status\n        2. If not running, restart it (sudo systemctl restart ssh)\n    3. Thhere could be a cance that SSH daemon (demon) configuration file is messed up so compare it with the base model of it (sudo nano /etc/ssh/sshd_config)\n        1. Any changes require a ssh restrat (sudo service ssh restart)\n    4. Sometimes you'll need the port number (ssh user@ip -p<nmm>)\n    5. Run SSH with more verbosity (ssh -vvv username@host)\n        1. Basically look at the logs in /var/log/auth.log (look for messages that contain sshd)\n\n# NETWORK PROTOCOLS (TCP & UDP)\n\n- TCP (Transmission Control Protocol)\n    - Connection-oriented meaning once a connection has been established, data can be transmitted in two directions\n    - Perfect protocol for transferring images, data files, and web pages\n    - TCP is SLOWER than UDP\n    - More overhead = more space\n    - TCP provides an ordered delivery of data from user to server (and vice versa)\n    - Data sequencing: possible!\n    - Optimal use: HTTPS, HTTP, SMTP, POP, FTP\n    - Stream type: byte stream\n\n- UDP (User Datagram Protocol):\n    - Connectionless protocol\n    - No overhead for opening a connection, maintaining a connection, or terminating a connection; data is continiously sent regardless of if it's being received successfuly or not\n    - Preferred for real-time communications like broadcast or multitask network transmission (so think real-time chatting over the internet)\n    - UDP is FASTER than TCP\n    - Less overhead = less space\n    - UDP is not dedicated to end-to-end communications, nor does it check the readienss of the receiver\n    - Data sequencing: not possible!\n    - Optimal use: video conferencing, streaming, DNS, VoIP\n    - Stream type: message stream\n\n# NETWORK VIRTUALIZATION\n- Abstracting network resources that were traditionally delivered in hardware to software. NV can combine multiple physical networks to one virtual, software-based network, or it can divide one physical network into separate, independent virtual networks.\n- Network virtualization software allows network administrators to move virtual machines across different domains without reconfiguring the network. The software creates a network overlay that can run separate virtual network layers on top of the same physical network fabric "}}, "01. Introduction": {"01. What is 1SRE?.md": "1SRE is a platform to learn about anything OS, networking, or other core operational related content for <b>free</b>; the objective of this application is to give college students, experienced professionals, and whomever else the necesseary tools to become a Site Reliability Engineer (or anything similar).\n\nThere are a lot of platforms for (general) software engineers to build their confidence in programming (i.e.: [Leetcode](https://leetcode.com/), [HackerRank](https://www.hackerrank.com/), [NeetCode](https://neetcode.io/), etc); however, there's nothing that covers concepts about OS (operating systems), the Kernel, networks (TCP/UDP/POP/FTP/etc), Ansible, CI/CD, and other buzz words in operational roles. Sure, it's possible to find manuals that cover each of these topics in depth by simply Googling them, but the purpose of 1SRE is to combine everything and spit it out onto one <i>source of truth</i>.\n\nIf anything, at the end of the day, the platform is truly meant for myself. My kind of work revolves around reilability engineering and I'm typically learning more things as I go; one day, I thought to myself that it'd be nice to have a little website to go back to whenever I needed the information (either for work or for general interview prep)...\n\nIf you find anything that needs to be corrected, please submit a PR request and I'll look at it when I get the chance. Whatever I write about is through experience or research, but I know with technology constantly changing, there's always a better or efficient approach to a problem or question.\n\nLastly, thank you so much for giving this a read. I'm excited to work on this platform moving forward and I hope to make a significant impact within the community.", "02. Where to get started?.md": "To cut it short, there's no proper way to go about reading the documents found on the website/[GitHub](https://github.com/1SRE/Manual); it's really up to you, the user, to dive anywhere across the vast amount of resources provided to you.\n\nThe way I plan on organizing the documents is to cover each topic at a very high level, but also work my way down to the intricacies of each topic (i.e.: starting in Linux in general then going into distrubutions, the Kernel, a typical boot sequence, etc).\n\nAs you can tell, the plan is somewhat disorganized for now, but eventually there'll be more consistency throughout the documents.\n\nFor the time being, the outline is as follows:\n\n|Topics|\n|--|\n|Operating Systems|\n|CI/CD|\n|Networking|\n|Scripting|\n|Infrastructure as code|\n|System Design|\n|more to come \ud83d\ude1b|", "03. Future plans.md": "The plan for now is to create documents and setup a pipeline to automatically display them as intended on 1SRE's website (at the time of writing, the domain hasn't been purchased yet \ud83d\ude2c... If it does get purchased, I'll just think of another name and go with that)\n\nFuture plans consist of:\n- Video demonstrations\n- Free labs\n- Premium features\n- Discord community\n- Please make a PR with more things that I can write here.. credit will be given \ud83d\ude1b"}}